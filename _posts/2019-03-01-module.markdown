---
layout:       post
title:        "前端模块化的进化史"
subtitle:     ""
date:         2019-03-02 21:00:00
author:       "boowen"
header-img:   "img/post-bg-module.png"
header-mask:  0.3
tags:
    - 前端
    - JS
---
>在公司接手了一个没有用任何框架的老项目，在这个项目了看到了原始的前端刀耕火种的局面。在维护这个项目的时候，我体会到了前端发展历史。

## 刀耕火种的局面
- 第一阶段：函数

在很久以前，我们的页面的很简单，功能很简单，用于提交一些简单的信息。那个时候没有前端工程师这个职位，大多数都是一些后端，顺便写下页面。当时就是简单的HTML + Css ＋Js。例子如下。

```
function getData(){
    // do something
}
function getName(){
    // do something
}
```
 这种早期的写法，在当时可以满足业务需求。但是放在现在复杂的业务里，缺点就暴露无遗了（如果是简单的静态页面，也无所谓）。有个明显的缺陷，全局变量污染。试想一下，在一个大型的项目里，有多个人一起合作，每个人写函数或者变量的时候，都需要看看同事又没有和你命名相同的函数或变量,避免产生冲突。这对于开发人员来说是个噩梦。所以很快进入到第二阶段。

 - 第二阶段：简单封装

把相关的功能的代码放进一个对象里。所以保证对象不重名，就可以放心的写自己想写的名字。例子如下：

```
var get = {
    getData: function(){},
    getName: function(){}
}

get.getName();
```
看似解决了第一阶段的冲突。但是由引出另一个问题了。这个对象里的函数和变量可以被引用者，随意更改。如果同事不小心修改了getData函数，这样就造成了危险。所以又想了一个办法。进入到第三阶段。

- 第三阶段：匿名闭包函数

利用函数的作用域和闭包的特性。减少了变量的污染和避免修改内部的代码。使用者在引用这个JS的时候，不用关心内部代码是怎么实现的。只用知道暴露了那些接口。同时没有暴露的接口，使用者也没有权限修改。例子如下。

```
var Module = (function(){
    var name = '小明';
    var age = '22';
    var sex = '秘密'
    funtion getName(){
        return name;
    }
    return {
        getName:getName
    }
})()
```
这就是模块化的最简单版，前辈们就在此基础上进行了优化和修改，投入到生产力，后续会有介绍。

## 我们解决了JS的问题，我们还面临新的问题：

JS的加载：

在以前的简单的项目里，JS的数量不多，所以问题不是和明显。直到有一天，我分享了一个自己写的JS库。同事觉得好用就拿去用了。但是过一会儿，同事就说，代码报错。后来排查出来，发现，同事没有引用这个库所依赖的文件。我虽然写了文档。但是同事们，并没有去看。随着项目的发展，页面引入的JS越来越多了。问题就越加的尖锐。大量的JS需要注意引用顺序。让开发变得异常恶心。例子如下

```
<script src="handele.js"></script>c
<script src="app.js"></script>
<!--省略 还有很多js-->
<script src="index.js"></script>
<script src="data.js"></script>
```

总结下，如果按照以前的JS引入方式，会出现以下问题：
（1）如果JS存在依赖文件，需要了解相关资料，确定引用顺序。
（2）难以维护，依赖过多,请求过多。
PS：我在维护这个项目的时候，如果有新的需求过来，就只有把以前的JS的复制一遍过来,感觉每个都有用，然后就在后面继续新添自己的代码。长期下去，项目只会越来越糟糕。
## 蒸汽时代

1.背景介绍：

发现问题了，自然就要解决问题。当NODE出现的时候，提出了模块化的概念。也就是大名鼎鼎的Common.js。前端看见了，自然也想拿过来。但是现实条件不允许直接拿来用。于是我们就想办法自己搞。诞生了AMD、CMD规范，还有相应的工具：webpack、gulp、grunt等等。

2.Common.js

Common.js这个规范是由Node.js提出。模块的引入的方法非常简单。例子如下：

```
// math.js
exports.add = function(a, b){
    return a + b;
}
// main.js
var math = require('math')      // ./math in node
console.log(math.add(1, 2));    // 3
```
缺点：

（1）服务器在本地取文件是非常快，浏览器的网络条件达不到，可能会造成页面长时间失去响应。

（2）浏览器是通过JS标签引入JS的，但是浏览器天生异步，所以不能确定JS加载的顺序。

虽然不能直接用于浏览器，但是大佬找到办法解决了，用browserify。这里不做详细介绍了。

3.AMD.js

这个规范是require.js产生的，遵循依赖前置。

```
// AMD 
define(["a", "b"], function(a, b){ // 依赖前置  
    a.doSomething();
    b.doSomething();
})
```
总结：AMD的特点是依赖的JS都是提前声明的好的,也就是依赖前置。在依赖文件下载，并且执行完成后，才会执行函数的内容。在性能上，策略为一劳永逸，在规模较大，模块较多时，首屏加载性能可能稍差，但是后续的运行会非常顺畅。

4.CMD.js

这个规范是sea.js产生的，依赖就近，延迟执行。

```
define(function(require, exports, module){
    var a = require("a");
    a.doSomething();
    var b = require("b");
    b.doSomething();    // 依赖就近，延迟执行
})
```

总结：CMD的特点是按需加载，立即执行。在性能上，策略是按需取物，即时执行，与AMD同等环境下，首屏加载性能较快，在后续运行中可能会有卡顿现象。

以上总结了前端的一点皮毛，本来还可以引申出webpack，babel等等一系列的东西。这些东西下次在做总结。












